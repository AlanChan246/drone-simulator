<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoDrone EDU Simulator - Robolink Style (Clear View)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://unpkg.com/blockly@9.3.3/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/msg/en.js"></script>

    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-bg: #111111;
            --text-color: #e0e0e0;
            --accent-color: #00adb5;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* È†ÇÈÉ®Â∞éËà™Âàó */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background-color: #2c3e50;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
            border-bottom: 2px solid #00adb5;
        }

        .top-bar h2 { margin: 0; color: white; font-size: 1.2rem; margin-right: 30px; }

        .control-btn {
            background-color: #34495e; color: white; border: none; padding: 8px 15px;
            margin-right: 10px; border-radius: 5px; cursor: pointer; font-weight: bold;
            display: flex; align-items: center; gap: 5px; transition: 0.2s;
        }
        .control-btn:hover { filter: brightness(1.2); }
        .btn-run { background-color: #27ae60; }
        .btn-stop { background-color: #c0392b; }
        .btn-reset { background-color: #e67e22; }
        
        .scene-select { padding: 5px 10px; border-radius: 4px; background: #ecf0f1; border: none; margin-left: auto; font-weight: bold; cursor: pointer; }

        .main-container { display: flex; width: 100%; height: calc(100vh - 50px); margin-top: 50px; }
        #blocklyDiv { width: 40%; height: 100%; background-color: var(--panel-bg); border-right: 1px solid #444; }
        #canvas-container { width: 60%; height: 100%; position: relative; background-color: #000; cursor: grab; overflow: hidden; }
        #canvas-container:active { cursor: grabbing; }

        .hud {
            position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7);
            padding: 15px; border-radius: 5px; font-family: 'Courier New', monospace;
            pointer-events: none; color: #00ff00; font-size: 0.95rem; line-height: 1.5;
            user-select: none; min-width: 180px; border: 1px solid #333;
        }

        /* Console Èù¢ÊùøÊ®£Âºè */
        #console-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background-color: rgba(30, 30, 30, 0.95);
            border-top: 2px solid #00adb5;
            display: flex;
            flex-direction: column;
            z-index: 20;
            transition: transform 0.3s;
        }

        .console-header {
            background-color: #2c3e50;
            color: white;
            padding: 5px 10px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
        }

        #console-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ff00;
            text-align: left;
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-time { color: #888; font-size: 0.8em; margin-right: 8px; }


    </style>
</head>
<body>

    <div class="top-bar">
        <h2>üöÅ CoDrone EDU Sim</h2>
        <button class="control-btn btn-run" onclick="runBlocklyCode()">‚ñ∂ RUN</button>
        <button class="control-btn btn-stop" onclick="emergencyStop()">‚¨õ STOP</button>
        <button class="control-btn btn-reset" onclick="resetSimulator()">‚ü≥ RESET</button>
        <select class="scene-select" id="scene-select" onchange="changeScene(this.value)">
            <option value="free">Â†¥ÊôØ: Ëá™Áî±È£õË°å</option>
            <option value="tunnel">‰ªªÂãô‰∏Ä: Êô∫ËÉΩÈößÈÅì</option>
            <option value="city">‰ªªÂãô‰∫å: ÂüéÂ∏ÇÁâ©ÊµÅ</option>
        </select>
    </div>

    <div class="main-container">
        <div id="blocklyDiv"></div>

        <div id="canvas-container">
            <div class="hud" id="hud-display">Status: LANDED<br>Alt: 0 cm</div>
            
            <div id="console-panel">
                <div class="console-header">
                    <span>>_ Console Output</span>
                    <button onclick="clearConsole()" style="background:none;border:none;color:#aaa;cursor:pointer;">üóëÔ∏è Clear</button>
                </div>
                <div id="console-content"></div>
            </div>
            </div>
    </div>

    <xml id="toolbox" style="display: none">
        <category name="Events" colour="#FFBF00">
            <block type="event_start"></block>
            <block type="event_wait_key"></block>
        </category>
        
        <category name="Flight Commands" colour="#4C97FF">
            <label text="Basic"></label>
            <block type="drone_takeoff"></block>
            <block type="drone_land"></block>
            <block type="drone_hover">
                <value name="DURATION"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
            </block>
            <block type="drone_move_time">
                <value name="DURATION"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
                <value name="POWER"><shadow type="math_number"><field name="NUM">50</field></shadow></value>
            </block>
            <block type="drone_move_cm">
                <value name="DIST"><shadow type="math_number"><field name="NUM">50</field></shadow></value>
            </block>
            <block type="drone_goto_xyz">
                <value name="X"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="Y"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="Z"><shadow type="math_number"><field name="NUM">0.8</field></shadow></value>
            </block>
            <block type="drone_turn_degree">
                <value name="DEGREE"><shadow type="math_number"><field name="NUM">90</field></shadow></value>
            </block>
            <block type="drone_turn_time">
                <value name="DURATION"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
                <value name="POWER"><shadow type="math_number"><field name="NUM">50</field></shadow></value>
            </block>
            <label text="Advanced"></label>
            <block type="drone_set_variable">
                <value name="VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
            </block>
            <block type="drone_turn_heading">
                <value name="DEGREE"><shadow type="math_number"><field name="NUM">90</field></shadow></value>
            </block>
            <block type="drone_move_complex">
                <value name="DURATION"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
            </block>
            <block type="drone_move_complex_infinite"></block>
        </category>

        <category name="Lights" colour="260">
            <block type="drone_set_led_color">
                <value name="COLOR"><shadow type="colour_picker"><field name="COLOUR">#ff0000</field></shadow></value>
                <value name="BRIGHTNESS"><shadow type="math_number"><field name="NUM">255</field></shadow></value>
            </block>
            <block type="drone_set_led_rgb">
                <value name="R_VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="G_VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="B_VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="BRIGHTNESS"><shadow type="math_number"><field name="NUM">255</field></shadow></value>
            </block>
            <block type="drone_led_off"></block>
            <label text="Light Sequences"></label>
            <block type="drone_led_sequence">
                <value name="R_VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="G_VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
                <value name="B_VAL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
            </block>
        </category>

        <category name="Sensors" colour="#5b67a5">
            <block type="drone_get_range">
                <field name="TYPE">front</field><field name="UNIT">cm</field>
            </block>
            <block type="drone_get_height"><field name="UNIT">cm</field></block>
        </category>

        <category name="Console" colour="#5ba5e0">
            <block type="drone_print">
                <value name="TEXT"><shadow type="text"><field name="TEXT">Hello</field></shadow></value>
            </block>
            <block type="text"></block>
            <block type="text_join"></block>
        </category>
        
        <sep></sep>

        <category name="Logic" colour="#5C81A6">
            <block type="logic_compare"></block>
            <block type="logic_operation"></block>
            <block type="logic_negate"></block>
            <block type="logic_boolean"></block>
            <block type="logic_ternary"></block>
        </category>

        <category name="Control" colour="#FFAB19">
            <block type="controls_if"></block>
            <block type="controls_repeat_ext">
                <value name="TIMES">
                    <shadow type="math_number"><field name="NUM">4</field></shadow>
                </value>
            </block>
            <block type="controls_whileUntil"></block>
            <block type="controls_flow_statements"></block>
        </category>

        <category name="Math" colour="#59C059">
            <block type="math_number"><field name="NUM">0</field></block>
            <block type="math_arithmetic"></block>
            <block type="math_random_int">
                <value name="FROM"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
                <value name="TO"><shadow type="math_number"><field name="NUM">100</field></shadow></value>
            </block>
            <block type="math_round"></block>
            <block type="math_modulo"></block>
        </category>

        <category name="Variables" colour="#a5c73d" custom="VARIABLE"></category>

        <category name="Functions" colour="#d65cd6" custom="PROCEDURE"></category>

    </xml>

    <script>
        // ==========================================
        // 1. Blockly Á©çÊú®ÂÆöÁæ© (‰øÆÊ≠£Áâà)
        // ==========================================
        
        Blockly.defineBlocksWithJsonArray([
            // --- Events ---
            {
                "type": "event_start",
                "message0": "when %1 clicked",
                "args0": [{"type": "field_image", "src": "https://www.gstatic.com/images/icons/material/system/1x/play_arrow_white_24dp.png", "width": 15, "height": 15, "alt": "play"}],
                "nextStatement": null, "colour": "#FFBF00", "tooltip": "Á®ãÂºèÈñãÂßã"
            },
            {
                "type": "event_wait_key",
                "message0": "wait for key input",
                "previousStatement": null, "nextStatement": null, "colour": "#FFBF00", "tooltip": "Êö´ÂÅúÁõ¥Âà∞Êåâ‰∏ãÁ©∫ÁôΩÈçµ"
            },
            // --- Basic Flight ---
            {
                "type": "drone_takeoff",
                "message0": "take off",
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_land",
                "message0": "land",
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_hover",
                "message0": "hover for %1 second(s)",
                "args0": [{ "type": "input_value", "name": "DURATION", "check": "Number" }],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_move_time",
                "message0": "go %1 for %2 second(s) at %3 %% power",
                "args0": [
                    { "type": "field_dropdown", "name": "DIR", "options": [["forward", "FORWARD"], ["backward", "BACKWARD"], ["left", "LEFT"], ["right", "RIGHT"], ["up", "UP"], ["down", "DOWN"]] },
                    { "type": "input_value", "name": "DURATION", "check": "Number" },
                    { "type": "input_value", "name": "POWER", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_move_cm",
                "message0": "go %1 %2 cm",
                "args0": [
                    { "type": "field_dropdown", "name": "DIR", "options": [["forward", "FORWARD"], ["backward", "BACKWARD"], ["left", "LEFT"], ["right", "RIGHT"], ["up", "UP"], ["down", "DOWN"]] },
                    { "type": "input_value", "name": "DIST", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_turn",
                "message0": "turn %1 %2 degrees",
                "args0": [
                    { "type": "field_dropdown", "name": "DIR", "options": [["left", "LEFT"], ["right", "RIGHT"]] },
                    { "type": "input_value", "name": "DEGREE", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_goto_xyz",
                "message0": "go to coordinate (x, y, z) = (%1, %2, %3) m",
                "args0": [
                    { "type": "input_value", "name": "X", "check": "Number" },
                    { "type": "input_value", "name": "Y", "check": "Number" },
                    { "type": "input_value", "name": "Z", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_turn_degree",
                "message0": "turn %1 %2 degrees",
                "args0": [
                    { "type": "field_dropdown", "name": "DIR", "options": [["left", "LEFT"], ["right", "RIGHT"]] },
                    { "type": "input_value", "name": "DEGREE", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            {
                "type": "drone_turn_time",
                "message0": "turn %1 for %2 second(s) at %3 %% power",
                "args0": [
                    { "type": "field_dropdown", "name": "DIR", "options": [["left", "LEFT"], ["right", "RIGHT"]] },
                    { "type": "input_value", "name": "DURATION", "check": "Number" },
                    { "type": "input_value", "name": "POWER", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#4C97FF"
            },
            // --- Advanced Flight ---
            {
                "type": "drone_set_variable",
                "message0": "set %1 to %2 %%",
                "args0": [
                    { "type": "field_dropdown", "name": "VAR", "options": [["roll", "ROLL"], ["pitch", "PITCH"], ["yaw", "YAW"], ["throttle", "THROTTLE"]] },
                    { "type": "input_value", "name": "VAL", "check": "Number" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": "#364d99"
            },
            {
                "type": "drone_turn_heading",
                "message0": "turn to heading %1 ¬∞",
                "args0": [{ "type": "input_value", "name": "DEGREE", "check": "Number" }],
                "previousStatement": null, "nextStatement": null, "colour": "#364d99"
            },
            {
                "type": "drone_move_complex",
                "message0": "move %1 second(s)",
                "args0": [{ "type": "input_value", "name": "DURATION", "check": "Number" }],
                "previousStatement": null, "nextStatement": null, "colour": "#364d99"
            },
            {
                "type": "drone_move_complex_infinite",
                "message0": "move()",
                "previousStatement": null, "nextStatement": null, "colour": "#364d99",
                "tooltip": "‰ΩøÁî®Áï∂ÂâçÂèÉÊï∏ÁßªÂãï‰∏ÄÂ∞èÊ≠•"
            },
            // --- Lights ---
            {
                "type": "drone_set_led_color",
                "message0": "set %1 LED color to %2 , with a brightness of %3",
                "args0": [
                    { "type": "field_dropdown", "name": "DRONE_ID", "options": [["drone", "DRONE_1"]] },
                    { "type": "input_value", "name": "COLOR" },
                    { "type": "input_value", "name": "BRIGHTNESS", "check": "Number" }
                ],
                "inputsInline": true,
                "previousStatement": null, "nextStatement": null, "colour": 260,
                "tooltip": "Set LED color and brightness"
            },
            {
                "type": "drone_set_led_rgb",
                "message0": "set %1 LED R= %2 , G= %3 , B= %4 , %5",
                "args0": [
                    { "type": "field_dropdown", "name": "DRONE_ID", "options": [["drone", "DRONE_1"]] },
                    { "type": "input_value", "name": "R_VAL", "check": "Number" },
                    { "type": "input_value", "name": "G_VAL", "check": "Number" },
                    { "type": "input_value", "name": "B_VAL", "check": "Number" },
                    { "type": "input_value", "name": "BRIGHTNESS", "check": "Number" }
                ],
                "inputsInline": true,
                "previousStatement": null, "nextStatement": null, "colour": 260,
                "tooltip": "Set custom RGB values"
            },
            {
                "type": "drone_led_off",
                "message0": "turn %1 LED off",
                "args0": [
                    { "type": "field_dropdown", "name": "DRONE_ID", "options": [["drone", "DRONE_1"]] }
                ],
                "inputsInline": true,
                "previousStatement": null, "nextStatement": null, "colour": 260,
                "tooltip": "Turn off LED"
            },
            {
                "type": "drone_led_sequence",
                "message0": "set %1 LED sequence %2 with color R= %3 , G= %4 , B= %5 and speed %6",
                "args0": [
                    { "type": "field_dropdown", "name": "DRONE_ID", "options": [["drone", "DRONE_1"]] },
                    { "type": "field_dropdown", "name": "SEQUENCE", "options": [["dimming", "DIMMING"], ["blinking", "BLINKING"]] },
                    { "type": "input_value", "name": "R_VAL", "check": "Number" },
                    { "type": "input_value", "name": "G_VAL", "check": "Number" },
                    { "type": "input_value", "name": "B_VAL", "check": "Number" },
                    { "type": "field_dropdown", "name": "SPEED", "options": [["1", "1"], ["2", "2"], ["3", "3"]] }
                ],
                "inputsInline": true,
                "previousStatement": null, "nextStatement": null, "colour": 260,
                "tooltip": "Play LED sequence"
            },
            // --- Sensors ---
            {
                "type": "drone_get_range",
                "message0": "get %1 range in %2",
                "args0": [
                    {
                        "type": "field_dropdown",
                        "name": "TYPE",
                        "options": [
                            ["front", "front"],
                            ["bottom", "bottom"]
                        ]
                    },
                    {
                        "type": "field_dropdown",
                        "name": "UNIT",
                        "options": [
                            ["cm", "cm"],
                            ["mm", "mm"],
                            ["in", "in"],
                            ["m", "m"]
                        ]
                    }
                ],
                "output": "Number",
                "colour": "#5b67a5",
                "tooltip": "Get distance from sensor"
            },
            {
                "type": "drone_get_height",
                "message0": "get height in %1",
                "args0": [
                    {
                        "type": "field_dropdown",
                        "name": "UNIT",
                        "options": [
                            ["cm", "cm"],
                            ["mm", "mm"],
                            ["in", "in"],
                            ["m", "m"]
                        ]
                    }
                ],
                "output": "Number",
                "colour": "#5b67a5",
                "tooltip": "Get drone height from bottom sensor"
            },
            // --- Console ---
            {
                "type": "drone_print",
                "message0": "print %1",
                "args0": [
                    {
                        "type": "input_value",
                        "name": "TEXT"
                    }
                ],
                "previousStatement": null,
                "nextStatement": null,
                "colour": 210, 
                "tooltip": "Print text to console log"
            },
        ]); // <--- ÈÄôË£°ÁµêÊùüÈô£ÂàóÂÆöÁæ©

        // --- Generator Functions ---
        Blockly.JavaScript['event_start'] = function(block) { return ""; };
        Blockly.JavaScript['event_wait_key'] = function(block) { return "cmdQueue.push({type: 'wait_key', text: 'Wait Key'});\n"; };

        Blockly.JavaScript['drone_takeoff'] = function(block) { return "cmdQueue.push({type: 'takeoff', text: 'Takeoff'});\n"; };
        Blockly.JavaScript['drone_land'] = function(block) { return "cmdQueue.push({type: 'land', text: 'Land'});\n"; };
        Blockly.JavaScript['drone_hover'] = function(block) {
            let d = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '1';
            return `cmdQueue.push({type: 'hover', param: ${d}, text: 'Hover ${d}s'});\n`;
        };
        Blockly.JavaScript['drone_move_time'] = function(block) {
            let dir = block.getFieldValue('DIR'); 
            let d = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '1';
            let p = Blockly.JavaScript.valueToCode(block, 'POWER', Blockly.JavaScript.ORDER_ATOMIC) || '50';
            return `cmdQueue.push({type: 'move_${dir.toLowerCase()}', param: ${d}, power: ${p}, text: 'Go ${dir} ${d}s'});\n`;
        };
        Blockly.JavaScript['drone_move_cm'] = function(block) {
            let dir = block.getFieldValue('DIR');
            let d = Blockly.JavaScript.valueToCode(block, 'DIST', Blockly.JavaScript.ORDER_ATOMIC) || '50';
            let timeCalc = `${d} / 50.0`; 
            return `cmdQueue.push({type: 'move_${dir.toLowerCase()}', param: ${timeCalc}, text: 'Go ${dir} ${d}cm'});\n`;
        };
        Blockly.JavaScript['drone_goto_xyz'] = function(block) {
            let x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let z = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return `cmdQueue.push({type: 'goto_xyz', x: ${x}*100, y: ${z}*100, z: ${y}*(-100), text: 'Goto (${x},${y},${z})m'});\n`; 
        };
        Blockly.JavaScript['drone_turn_degree'] = function(block) {
            let dir = block.getFieldValue('DIR');
            let d = Blockly.JavaScript.valueToCode(block, 'DEGREE', Blockly.JavaScript.ORDER_ATOMIC) || '90';
            return `cmdQueue.push({type: 'turn_${dir.toLowerCase()}', param: ${d}, text: 'Turn ${dir} ${d}¬∞'});\n`;
        };
        Blockly.JavaScript['drone_turn_time'] = function(block) {
            let dir = block.getFieldValue('DIR');
            let d = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '1';
            let p = Blockly.JavaScript.valueToCode(block, 'POWER', Blockly.JavaScript.ORDER_ATOMIC) || '50';
            return `cmdQueue.push({type: 'turn_time', dir: '${dir}', param: ${d}, power: ${p}, text: 'Turn ${dir} ${d}s'});\n`;
        };
        Blockly.JavaScript['drone_set_variable'] = function(block) {
            let v = block.getFieldValue('VAR');
            let val = Blockly.JavaScript.valueToCode(block, 'VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return `cmdQueue.push({type: 'set_var', var: '${v}', val: ${val}, text: 'Set ${v} ${val}%'});\n`;
        };
        Blockly.JavaScript['drone_turn_heading'] = function(block) {
            let h = Blockly.JavaScript.valueToCode(block, 'DEGREE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return `cmdQueue.push({type: 'set_heading', val: ${h}, text: 'Heading ${h}¬∞'});\n`;
        };
        Blockly.JavaScript['drone_move_complex'] = function(block) {
            let d = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '1';
            return `cmdQueue.push({type: 'move_complex', param: ${d}, text: 'Move(${d}s)'});\n`;
        };
        Blockly.JavaScript['drone_move_complex_infinite'] = function(block) {
            return `cmdQueue.push({type: 'move_complex', param: 0.1, text: 'Move()'});\n`;
        };
        Blockly.JavaScript['drone_set_color'] = function(block) {
            let c = block.getFieldValue('COLOR');
            return `cmdQueue.push({type: 'set_color', param: '${c}', text: 'LED ${c}'});\n`;
        };
        // --- Light ÁîüÊàêÈÇèËºØ ---
        
        Blockly.JavaScript['drone_set_led_color'] = function(block) {
            let color = Blockly.JavaScript.valueToCode(block, 'COLOR', Blockly.JavaScript.ORDER_ATOMIC) || "'#ff0000'";
            let bright = Blockly.JavaScript.valueToCode(block, 'BRIGHTNESS', Blockly.JavaScript.ORDER_ATOMIC) || '255';
            return `cmdQueue.push({type: 'led_hex_bright', color: ${color}, brightness: ${bright}, text: 'LED ' + ${color} + ' (' + ${bright} + ')'});\n`;
        };

        Blockly.JavaScript['drone_set_led_rgb'] = function(block) {
            let r = Blockly.JavaScript.valueToCode(block, 'R_VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let g = Blockly.JavaScript.valueToCode(block, 'G_VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let b = Blockly.JavaScript.valueToCode(block, 'B_VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let br = Blockly.JavaScript.valueToCode(block, 'BRIGHTNESS', Blockly.JavaScript.ORDER_ATOMIC) || '255';
            return `cmdQueue.push({type: 'led_rgb', r: ${r}, g: ${g}, b: ${b}, brightness: ${br}, text: 'LED RGB(' + ${r} + ',' + ${g} + ',' + ${b} + ')'});\n`;
        };

        Blockly.JavaScript['drone_led_off'] = function(block) {
            return `cmdQueue.push({type: 'led_off', text: 'LED OFF'});\n`;
        };

        Blockly.JavaScript['drone_led_sequence'] = function(block) {
            let seq = block.getFieldValue('SEQUENCE'); // Ê≥®ÊÑèÈÄôË£°ËÆäÊàê‰∫Ü SEQUENCE
            let r = Blockly.JavaScript.valueToCode(block, 'R_VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let g = Blockly.JavaScript.valueToCode(block, 'G_VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let b = Blockly.JavaScript.valueToCode(block, 'B_VAL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            // Speed Âú®ÂéüÊú¨ÁöÑÊ®°Êì¨Âô®ÈÇèËºØÈÇÑÊ≤íÁî®Âà∞ÔºåÊö´ÊôÇ‰∏çËôïÁêÜÔºå‰∏çÂΩ±ÈüøÂü∑Ë°å
            return `cmdQueue.push({type: 'led_seq', seq: '${seq}', r: ${r}, g: ${g}, b: ${b}, text: 'Seq: ${seq}'});\n`;
        };

        Blockly.JavaScript['drone_get_range'] = function(block) {
            var sensorType = block.getFieldValue('TYPE');
            var unit = block.getFieldValue('UNIT');
            // ÁîüÊàêÂëºÂè´Ê®°Êì¨Âô®ÂáΩÂºèÁöÑÁ®ãÂºèÁ¢º
            var code = `getSensorReading('${sensorType}', '${unit}')`; 
            // Âõ†ÁÇ∫ÈÄôÊòØÂõûÂÇ≥ÂÄºÁöÑÁ©çÊú®ÔºåË¶ÅÁî® tuple Ê†ºÂºèÂõûÂÇ≥
            return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript['drone_get_height'] = function(block) {
            var unit = block.getFieldValue('UNIT');
            var code = `getSensorReading('bottom', '${unit}')`;
            return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript['drone_print'] = function(block) {
            // ÂèñÂæóÈÄ£Êé•ÁöÑÊï∏ÂÄº‰ª£Á¢º (‰æãÂ¶Ç getSensorReading(...))
            var msgCode = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_NONE) || "''";
            
            // ÂèñÂæó‰æÜÊ∫êÁ©çÊú®
            var targetBlock = block.getInputTargetBlock('TEXT');
            
            var prefix = ""; // ÂâçÁ∂¥ (‰æãÂ¶Ç "Height: ")
            var suffix = ""; // ÂæåÁ∂¥ (‰æãÂ¶Ç " cm")

            if (targetBlock) {
                if (targetBlock.type === 'drone_get_height') {
                    // 1. Â¶ÇÊûúÊòØÈ´òÂ∫¶Á©çÊú®
                    prefix = "Height: ";
                    // ÂèñÂæóÁ©çÊú®‰∏äÈÅ∏ÁöÑÂñÆ‰Ωç (cm, m, in...)
                    var unit = targetBlock.getFieldValue('UNIT'); 
                    suffix = " " + unit; 

                } else if (targetBlock.type === 'drone_get_range') {
                    // 2. Â¶ÇÊûúÊòØË∑ùÈõ¢Á©çÊú®
                    var rangeType = targetBlock.getFieldValue('TYPE');
                    var unit = targetBlock.getFieldValue('UNIT');
                    
                    if (rangeType === 'front') prefix = "Front Range: ";
                    else prefix = "Bottom Range: ";
                    
                    suffix = " " + unit;
                }
            }
            
            // ÁîüÊàê‰ª£Á¢ºÔºöÂâçÁ∂¥ + Êï∏ÂÄº + ÂñÆ‰Ωç
            return `cmdQueue.push({
                type: 'print', 
                fn: () => "${prefix}" + ${msgCode} + "${suffix}", 
                text: 'Print Output'
            });\n`;
        };

        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: document.getElementById('toolbox'),
            scrollbars: true, trashcan: true,
            grid: { spacing: 20, length: 3, colour: '#ccc', snap: true },
            theme: { 'base': 'classic', 'componentStyles': { 'workspaceBackgroundColour': '#1e1e1e', 'toolboxBackgroundColour': '#2d2d2d' } }
        });

        // ==========================================
        // 2. Ê®°Êì¨Âô®Ê†∏ÂøÉ (3D Environment & Logic)
        // ==========================================
        
        const container = document.getElementById('canvas-container');
        let scene, camera, renderer, droneGroup;
        let environmentGroup; 
        let droneLedLight, droneLedMesh;  
        let propellers = [];
        let cmdQueue = []; 
        let currentSceneType = 'free'; 
        let tunnelWallData = []; 
        let cityOrder = null; 
        let hasHoveredTower = false; 
        let currentScore = 0;      // ÁõÆÂâçÂàÜÊï∏
        let hasTakenOff = false;   // ÊòØÂê¶Â∑≤Á∂ìËµ∑È£õÈÅé
        let targetPosition = { x: 0, z: 0 }; // ÁõÆÊ®ôÈôçËêΩÈªû (ÊúÉÈö®Â†¥ÊôØÊîπËÆä)
        let lightScore = 40;       // „ÄêÊñ∞Â¢û„ÄëÁáàÂÖâÈÇèËºØÂàÜÊï∏ (È†êË®≠ 40)
        let lastCheckTime = 0;     // „ÄêÊñ∞Â¢û„ÄëÁî®‰æÜÊéßÂà∂ 10Hz Êé°Ê®£È†ªÁéá
        let currentLedHex = '#000000'; // „ÄêÊñ∞Â¢û„ÄëË®òÈåÑÁõÆÂâç LED È°èËâ≤

        // È£õË°åÁãÄÊÖãËÆäÊï∏
        let flightState = { roll: 0, pitch: 0, yaw: 0, throttle: 0 };
        
        // ÊîùÂΩ±Ê©üËàáÊìç‰ΩúËÆäÊï∏
        let camRadius = 600; let camTheta = 45; let camPhi = 50;   
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        const state = { x: 0, y: 0, z: 0, heading: 0, isFlying: false, isRunning: false, stopSignal: false };
        let waitingForKey = false;

        // --- Âª∫Á´ãÂÅúÊ©üÂù™Áâ©‰ª∂ ---
        function createLandingPad(x, z) {
            // 1. ÂèñÂæóÂãïÊÖãÁîüÊàêÁöÑË≤ºÂúñ
            const canvas = createLandingPadTexture();
            const texture = new THREE.CanvasTexture(canvas);
            
            // 2. Âª∫Á´ãÊùêË≥™
            const geometry = new THREE.PlaneGeometry(40, 40);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true, 
                side: THREE.DoubleSide
            });
            
            const pad = new THREE.Mesh(geometry, material);
            
            // 3. Ë™øÊï¥‰ΩçÁΩÆ
            pad.rotation.x = -Math.PI / 2; // Âπ≥Êîæ
            pad.position.set(x, 0.2, z);   // Â¢äÈ´ò‰∏ÄÈªûÈªûÈÅøÂÖçÈñÉÁàç
            
            return pad;
        }

        // --- H ÂÅúÊ©üÂù™Ë≤ºÂúñ ---
        function createLandingPadTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // 1. Ê∏ÖÁ©∫ËÉåÊôØ (ÈÄèÊòé)
            ctx.clearRect(0, 0, size, size);

            // 2. Áï´Ê∑±ÁÅ∞Ëâ≤Â∫ïÂúì
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = 200;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#333333'; // Ê∑±ÁÅ∞Ëâ≤
            ctx.fill();

            // 3. Áï´Â§ñÂúàËôõÁ∑ö
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 20, 0, Math.PI * 2);
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 10;
            ctx.setLineDash([25, 15]); // Ë®≠ÂÆöËôõÁ∑öÈñìÈöî
            ctx.stroke();

            // 4. Áï´‰∏≠ÈñìÁöÑ "H"
            ctx.font = 'bold 280px Arial';
            ctx.fillStyle = '#ccff00'; // Ëû¢ÂÖâÈªÉ (ÂèÉËÄÉ‰Ω†ÁöÑÊà™Âúñ)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Á®çÂæÆË™øÊï¥ y ‰ΩçÁΩÆËÆìÂÆÉÂûÇÁõ¥ÁΩÆ‰∏≠
            ctx.fillText('H', centerX, centerY + 20); 

            return canvas;
        }

        // ÂàùÂßãÂåñ 3D Áí∞Â¢É
        function init3D() {
            scene = new THREE.Scene(); 
            // 1. „ÄêËÉåÊôØË™ø‰∫Æ„ÄëÂæûÊ•µÈªë (0x111111) ÊîπÁÇ∫Ê∑±ÁÅ∞ (0x252525)
            scene.background = new THREE.Color(0x252525);
            // ÈúßÊ∞£È°èËâ≤Ë¶ÅË∑üËÉåÊôØÂêåÊ≠•Ôºå‰∏çÁÑ∂ÈÅ†ËôïÊúÉÊúâËâ≤Â∑Æ
            scene.fog = new THREE.Fog(0x252525, 200, 2000);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 4000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true; 
            container.appendChild(renderer.domElement);

            // 2. „ÄêÁáàÂÖâÂ¢ûÂº∑„Äë
            // Áí∞Â¢ÉÂÖâÔºöÊîπÊàêÁôΩËâ≤ (0xffffff) ‰∏îÂº∑Â∫¶ 0.8ÔºåÁ¢∫‰øùÊâÄÊúâËßíËêΩÈÉΩÁúãÂæóÂà∞
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
            scene.add(ambientLight);
            
            // ‰∏ªÂÖâÊ∫êÔºöÂº∑Â∫¶ÊèêÂçáÂà∞ 1.2
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); 
            dirLight.position.set(100, 400, 100); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096; 
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.left = -1000; dirLight.shadow.camera.right = 1000;
            dirLight.shadow.camera.top = 1000; dirLight.shadow.camera.bottom = -1000;
            scene.add(dirLight);

            // 3. „ÄêÂú∞ÊùøÊ†ºÁ∑öË™ø‰∫Æ„ÄëÈÄôÊòØËÆì‰Ω†ÁúãÊ∏ÖÊ•öÂú∞Èù¢ÁöÑÈóúÈçµÔºÅ
            // ÂèÉÊï∏Ôºö(Â§ßÂ∞è, Ê†ºÊï∏, ‰∏≠ÂøÉÁ∑öÈ°èËâ≤, Ê†ºÁ∑öÈ°èËâ≤)
            // ‰∏≠ÂøÉÁ∑öÁî®ÈùíËâ≤ (0x00adb5) ÈÖçÂêà‰Ω†ÁöÑ UIÔºåÊ†ºÁ∑öÁî®Ê∑∫ÁÅ∞ (0x666666) ËÆìÂÆÉÂú®ËÉåÊôØ‰∏äË∑≥Âá∫‰æÜ
            const gridHelper = new THREE.GridHelper(2000, 50, 0x00adb5, 0x666666); 
            scene.add(gridHelper);

            // Áí∞Â¢ÉÁæ§ÁµÑ
            environmentGroup = new THREE.Group(); 
            scene.add(environmentGroup);

            // Âª∫Á´ãÁÑ°‰∫∫Ê©ü
            createDroneModel();
            
            // È†êË®≠ËºâÂÖ•Ëá™Áî±È£õË°å
            loadScene('free');

            // ‰∫ã‰ª∂Áõ£ËÅΩ
            window.addEventListener('resize', onWindowResize);
            container.addEventListener('mousedown', (e) => { isMouseDown = true; mouseX = e.clientX; mouseY = e.clientY; });
            window.addEventListener('mouseup', () => { isMouseDown = false; });
            window.addEventListener('mousemove', onMouseMove);
            container.addEventListener('wheel', onMouseWheel);
            
            // ÈçµÁõ§Áõ£ËÅΩ (Wait Key)
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && waitingForKey) {
                    waitingForKey = false;
                }
            });

            animateLoop();
        }

        // --- Â†¥ÊôØÁÆ°ÁêÜËàáÂàáÊèõ ---

        function changeScene(type) {
            currentSceneType = type;
            loadScene(type);
            resetSimulator(); // ÂàáÊèõÂ†¥ÊôØÊôÇÈáçÁΩÆÁÑ°‰∫∫Ê©ü‰ΩçÁΩÆ
        }

        function loadScene(type) {
            // Ê∏ÖÈô§ËàäÂ†¥ÊôØÁâ©‰ª∂
            while(environmentGroup.children.length > 0){ 
                environmentGroup.remove(environmentGroup.children[0]); 
            }
            tunnelWallData = []; 

            // ÈáçÁΩÆË®àÂàÜÁãÄÊÖã
            currentScore = 0; 
            lightScore = 40; // „ÄêÊñ∞Â¢û„ÄëÈáçÁΩÆÁáàÂÖâÂàÜÊï∏
            hasTakenOff = false;
            currentLedHex = '#000000'; // ÈáçÁΩÆÈ°èËâ≤

            // Ê†πÊìöÈ°ûÂûãËºâÂÖ•ÂÆåÊï¥Â†¥ÊôØ
            if (type === 'tunnel') {
                createTunnelMap();
                // ‰ªªÂãô‰∏ÄÔºöÁµÇÈªûÂú®ÂâçÊñπ -500cm Ëôï
                targetPosition = { x: 0, z: -500 }; 
            } else if (type === 'city') {
                createCityMap();
                // ‰ªªÂãô‰∫åÔºöÁµÇÈªûË®≠Âú® Zone Z (ÈößÈÅìÂæåÊñπ)
                targetPosition = { x: 0, z: -650 }; 
            } else {
                createFreeFlightMap();
                // Ëá™Áî±È£õË°åÔºöÂÅáË®≠ÁµÇÈªûÂ∞±ÊòØËµ∑Èªû (Á∑¥ÁøíÂÆöÈªûÈôçËêΩ)
                targetPosition = { x: 0, z: 0 }; 
            }
    
        }

        // 1. Ëá™Áî±È£õË°åÂ†¥ÊôØ
        function createFreeFlightMap() {
            const landingPad = createLandingPad(0, 0);
            environmentGroup.add(landingPad);
            
            // ÊîæÁΩÆÂõõÂÄãËßíËêΩÁöÑÂèÉËÄÉÈåêÈ´î (‰øùÁïôÂéüÊú¨ÁöÑ)
            const coneGeo = new THREE.ConeGeometry(10, 30, 32);
            const coneMat = new THREE.MeshPhongMaterial({ color: 0x00adb5 });
            [{x:200, z:-200}, {x:-200, z:-200}, {x:200, z:200}, {x:-200, z:200}].forEach(pos => {
                const cone = new THREE.Mesh(coneGeo, coneMat);
                cone.position.set(pos.x, 15, pos.z);
                environmentGroup.add(cone);
            });
        }

        // 2. Êô∫ËÉΩÈößÈÅìÂ†¥ÊôØ (ÂÆåÊï¥Áâà)
        function createTunnelMap() {
            const rightBoundaryX = 300; 
            
            // Âè≥ÂÅ¥‰∏çË¶èÂâáÁâÜÂ£Å
            for (let z = 50; z >= -600; z -= 20) {
                let dist = 120 + (Math.random() * 50 - 25); 
                if (z < -280 && z > -320) dist = 40; // Èô∑Èò±ÂçÄ
                
                tunnelWallData.push({ z: z, dist: dist });
                
                const wallHeight = 150; 
                const blockWidth = rightBoundaryX - dist; 
                const wallMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(blockWidth, wallHeight, 20),
                    new THREE.MeshPhongMaterial({ color: 0x888888 })
                );
                wallMesh.position.set(dist + (blockWidth / 2), wallHeight / 2, z);
                wallMesh.castShadow = true; 
                environmentGroup.add(wallMesh);
            }

            // Â∑¶ÂÅ¥ÁâÜÂ£Å
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(20, 150, 700), new THREE.MeshPhongMaterial({ color: 0x444444 }));
            leftWall.position.set(-100, 75, -250); 
            leftWall.receiveShadow = true; 
            environmentGroup.add(leftWall);
            
            // Ëµ∑ÈªûËàáÁµÇÈªû
            const landingPad = createLandingPad(0, 0);
            environmentGroup.add(landingPad);
            
            const pad = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent:true, opacity:0.6 }));
            pad.position.set(0, 1, -500); environmentGroup.add(pad);
        }

        // 3. ÂüéÂ∏ÇÁâ©ÊµÅÂ†¥ÊôØ (ÂÆåÊï¥Áâà)
        function createCityMap() {
            // ‰ø°ËôüÂ°î
            const towerBase = new THREE.Mesh(new THREE.CylinderGeometry(20, 30, 150, 32), new THREE.MeshPhongMaterial({ color: 0xffff00 }));
            towerBase.position.set(0, 75, -250); towerBase.castShadow = true; environmentGroup.add(towerBase);
            const towerTop = new THREE.Mesh(new THREE.SphereGeometry(15, 32, 32), new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true }));
            towerTop.position.set(0, 160, -250); environmentGroup.add(towerTop);
            
            // Zone X (ÈñòÈñÄ)
            const zoneXPad = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), new THREE.MeshBasicMaterial({ color: 0x00ffff })); 
            zoneXPad.position.set(-300, 1, -500); environmentGroup.add(zoneXPad);
            createBuilding(-400, -350, 80, 400, 200); createBuilding(-200, -350, 80, 400, 200);
            const lowGate = new THREE.Mesh(new THREE.BoxGeometry(120, 40, 10), new THREE.MeshPhongMaterial({ color: 0xcc4444 }));
            lowGate.position.set(-300, 20, -350); environmentGroup.add(lowGate);
            const highGate = new THREE.Mesh(new THREE.BoxGeometry(120, 60, 10), new THREE.MeshPhongMaterial({ color: 0xcc4444 }));
            highGate.position.set(-300, 100, -420); environmentGroup.add(highGate);

            // Zone Y (È´òÂè∞)
            const zoneYCol = new THREE.Mesh(new THREE.CylinderGeometry(30, 30, 120, 32), new THREE.MeshPhongMaterial({ color: 0x555555 }));
            zoneYCol.position.set(300, 60, -500); environmentGroup.add(zoneYCol);
            const zoneYPad = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), new THREE.MeshBasicMaterial({ color: 0xff00ff })); 
            zoneYPad.position.set(300, 122, -500); environmentGroup.add(zoneYPad);
            createBuilding(200, -500, 80, 100, 250); createBuilding(400, -500, 80, 100, 250); createBuilding(300, -600, 200, 80, 250);

            // Zone Z (ÈößÈÅì)
            const zoneZPad = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 60), new THREE.MeshBasicMaterial({ color: 0xffaa00 })); 
            zoneZPad.position.set(0, 1, -650); environmentGroup.add(zoneZPad);
            const tunnelTube = new THREE.Mesh(new THREE.CylinderGeometry(40, 40, 200, 32, 1, true), new THREE.MeshPhongMaterial({ color: 0x888888, side: THREE.DoubleSide }));
            tunnelTube.rotation.x = Math.PI / 2; tunnelTube.position.set(0, 40, -500); environmentGroup.add(tunnelTube);
            createBuilding(-60, -500, 40, 200, 100); createBuilding(60, -500, 40, 200, 100);

            // Ëµ∑Èªû
            const landingPad = createLandingPad(0, 0);
            environmentGroup.add(landingPad);
        }

        // ËºîÂä©ÂáΩÊï∏ÔºöÂª∫Á´ãÂª∫ÁØâÁâ©
        function createBuilding(x, z, w, d, h, color=0x333344) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshPhongMaterial({ color: color }));
            mesh.position.set(x, h/2, z); 
            mesh.castShadow = true; 
            mesh.receiveShadow = true; 
            environmentGroup.add(mesh);
        }

        // Âª∫Á´ãÁÑ°‰∫∫Ê©üÊ®°Âûã (CoDrone EDU StyleÔºâ
        function createDroneModel() {
            droneGroup = new THREE.Group();
            
            // „Äê‰øÆÊ≠£ÈóúÈçµ„ÄëÂ∞áÊâÄÊúâÈõ∂‰ª∂ÂæÄ‰∏äÊä¨È´ò 1.5ÔºåËÆìÂ∫ïÈÉ®ÂâõÂ•ΩÊé•Ëß∏Âú∞Èù¢ (y=0)
            const elevation = 1.5; 

            // ÂÆöÁæ©ÊùêË≥™
            const frameColor = 0x222222; 
            const frameMat = new THREE.MeshPhongMaterial({ color: frameColor, flatShading: false });
            
            // 1. ‰∏≠Â§ÆÊ©üË∫´
            const bodyGeo = new THREE.CylinderGeometry(5, 5, 2.5, 32);
            const body = new THREE.Mesh(bodyGeo, frameMat);
            body.scale.set(1, 1, 1.4); 
            body.castShadow = true;
            // ÂéüÊú¨ÊòØ (0,0,0) -> ÊîπÁÇ∫ (0, elevation, 0)
            body.position.set(0, elevation, 0); 
            droneGroup.add(body);

            // 2. È†ÇÈÉ® LED
            const ledGeo = new THREE.SphereGeometry(4, 32, 16);
            ledGeo.scale(1, 0.2, 1.3); 
            droneLedMesh = new THREE.Mesh(ledGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            // ÂéüÊú¨ y=1.3 -> ÊîπÁÇ∫ 1.3 + elevation
            droneLedMesh.position.set(0, 1.3 + elevation, 0); 
            droneGroup.add(droneLedMesh);
            
            droneLedLight = new THREE.PointLight(0x00ff00, 2, 40);
            droneLedLight.position.set(0, 5 + elevation, 0); 
            droneGroup.add(droneLedLight);
            
            // 3. Ëû∫ÊóãÊß≥ËàáÊîØÊû∂
            const armConfig = [
                {x:-9, z:-9, color: 0xff0000}, 
                {x: 9, z:-9, color: 0xff0000}, 
                {x:-9, z: 9, color: 0x111111}, 
                {x: 9, z: 9, color: 0x111111}  
            ];

            armConfig.forEach(pos => {
                // A. ‰øùË≠∑ÁΩ© (Guards)
                const guardGeo = new THREE.TorusGeometry(5.5, 0.3, 8, 32);
                const guard = new THREE.Mesh(guardGeo, frameMat);
                guard.rotation.x = Math.PI / 2; 
                // ÂéüÊú¨ y=0 -> ÊîπÁÇ∫ elevation
                guard.position.set(pos.x, elevation, pos.z);
                droneGroup.add(guard);

                // B. ÈÄ£Êé•ÊîØÊû∂ (Struts)
                const strutGeo = new THREE.BoxGeometry(9, 0.5, 1.5);
                const strut = new THREE.Mesh(strutGeo, frameMat);
                // ÂéüÊú¨ y=-0.5 -> ÊîπÁÇ∫ -0.5 + elevation
                strut.position.set(pos.x / 2, -0.5 + elevation, pos.z / 2);
                strut.rotation.y = Math.atan2(pos.z, pos.x);
                droneGroup.add(strut);

                // C. È¶¨ÈÅîÂ∫ß (Motor Housing) - ÈÄôÊòØÊúÄ‰ΩéÈªû (È´ò3Ôºå‰∏≠ÂøÉ0ÔºåÂ∫ï-1.5)
                const motor = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 3, 16), frameMat);
                // ÂéüÊú¨ y=0 -> ÊîπÁÇ∫ elevation (ÈÄôÊ®£Â∫ïÈÉ®ÂâõÂ•ΩÂú® 1.5 - 1.5 = 0)
                motor.position.set(pos.x, elevation, pos.z); 
                droneGroup.add(motor);
                
                // D. Ëû∫ÊóãÊß≥ (Propellers)
                const propGeo = new THREE.BoxGeometry(10, 0.15, 0.8);
                const propMat = new THREE.MeshBasicMaterial({
                    color: pos.color, 
                    transparent: true, 
                    opacity: 0.9
                });
                const prop = new THREE.Mesh(propGeo, propMat);
                // ÂéüÊú¨ y=1.6 -> ÊîπÁÇ∫ 1.6 + elevation
                prop.position.set(pos.x, 1.6 + elevation, pos.z); 
                
                propellers.push(prop); 
                droneGroup.add(prop);
            });

            scene.add(droneGroup);
        }

        // --- Áâ©ÁêÜÈÇèËºØ ---

        // ÂèñÂæóÂú∞Èù¢È´òÂ∫¶ (Èò≤Ê≠¢Á©øÁâÜ)
        function getGroundHeight(x, z) {
            if (currentSceneType === 'city') {
                // ‰ø°ËôüÂ°î
                const distToTower = Math.sqrt(Math.pow(x - 0, 2) + Math.pow(z - (-250), 2));
                if (distToTower < 25) return 150; 
                // Zone Y Âπ≥Âè∞
                const distToY = Math.sqrt(Math.pow(x - 300, 2) + Math.pow(z - (-500), 2));
                if (distToY < 30) return 120; 
                
                // Âª∫ÁØâÁâ©È†ÇÈÉ® (Á∞°ÂñÆÂà§Êñ∑)
                if (x > -440 && x < -360 && z > -550 && z < -150) return 200; // Zone X Â∑¶ÁâÜ
                if (x > -240 && x < -160 && z > -550 && z < -150) return 200; // Zone X Âè≥ÁâÜ
            }
            return 0; 
        }

        // ‰ªªÂãô‰∫åÈÇèËºØÔºöÊ™¢Êü•ÊòØÂê¶Êé•Ëß∏‰ø°ËôüÂ°î
        function checkCityLogic() {
            if (currentSceneType !== 'city') return;
            const distToTower = Math.sqrt(Math.pow(state.x - 0, 2) + Math.pow(state.z - (-250), 2));
            if (!hasHoveredTower && distToTower < 40 && state.y >= 140) {
                if (cityOrder === null) {
                    cityOrder = Math.floor(Math.random() * 3) + 1; hasHoveredTower = true;
                }
            }
        }

        // --- Êñ∞Â¢ûÔºöÊ®°Êì¨ÂÇ≥ÊÑüÂô®ËÆÄÊï∏ ---
        function getSensorReading(type, unit) {
            // Ê≥®ÊÑèÔºöÂõ†ÁÇ∫ÁõÆÂâçÁöÑÊ®°Êì¨Âô®ÊòØ„ÄåÈ†êÂÖàÁîüÊàêÊåá‰ª§„ÄçÔºåÈÄôÂÄãÊï∏ÂÄºÊúÉÊòØ„ÄåÊåâ‰∏ã RUN Áû¨Èñì„ÄçÁöÑÊï∏ÂÄº„ÄÇ
            // Â¶ÇÊûúË¶ÅÂú®È£õË°å‰∏≠ÂãïÊÖãÂà§Êñ∑ÔºåÈúÄË¶ÅÊõ¥ÈÄ≤ÈöéÁöÑÊ®°Êì¨Âô®Êû∂Êßã„ÄÇ
            // ÈÄôË£°ÊàëÂÄëÂÖàÂØ¶‰ΩúÂü∫Êú¨ÁöÑË∑ùÈõ¢Ë®àÁÆó„ÄÇ

            let value = 0;

            if (type === 'bottom') {
                // Â∫ïÈÉ®ÂÇ≥ÊÑüÂô® = Áï∂ÂâçÈ´òÂ∫¶ (y) - Âú∞Èù¢È´òÂ∫¶
                let groundY = getGroundHeight(state.x, state.z);
                value = Math.max(0, state.y - groundY);
            } else if (type === 'front') {
                // ÂâçÊñπÂÇ≥ÊÑüÂô® = Á∞°ÂñÆÊ®°Êì¨ÂâçÊñπÊòØÂê¶ÊúâÈöúÁ§ôÁâ©
                // ÈÄôË£°ÂÅö‰∏ÄÂÄãÁ∞°ÂñÆÁöÑÂ∞ÑÁ∑öÊ™¢Ê∏¨Ê®°Êì¨
                let rad = THREE.MathUtils.degToRad(state.heading);
                let dirX = -Math.sin(rad); // ÂâçÊñπÂêëÈáè X
                let dirZ = -Math.cos(rad); // ÂâçÊñπÂêëÈáè Z
                
                // È†êË®≠ÊúÄÂ§ßË∑ùÈõ¢ 150cm (1.5m)
                let minDist = 150; 
                
                // Á∞°ÂñÆÊ™¢Êü•Â†¥ÊôØÈÇäÁïåÊàñÁâÜÂ£Å (ÈÄôË£°‰ª• Tunnel Â†¥ÊôØÁöÑÁâÜÂ£ÅÁÇ∫‰æã)
                if (currentSceneType === 'tunnel') {
                   // Á∞°ÂåñÁöÑÊ®°Êì¨ÔºöÊ™¢Êü•ÂâçÊñπ 150cm ÂÖßÊúâÊ≤íÊúâÁ¢∞Âà∞ÁâÜÂ£Å
                   // ÈÄôË£°ÂÉÖÂõûÂÇ≥Ê®°Êì¨Êï∏ÂÄºÔºåÂØ¶ÈöõÂ∞ÑÁ∑öÊ™¢Ê∏¨Âú® 3D ‰∏≠ËºÉË§áÈõúÔºåÈÄôË£°ÂõûÂÇ≥‰∏ÄÂÄãÂÆâÂÖ®ÂÄºÊàñÈö®Ê©üÂÄºÊ®°Êì¨
                   // Ëã•Ë¶ÅÁúüÂØ¶ÔºåÈúÄË¶ÅÈÅçÊ≠∑ tunnelWallData
                   value = 150; 
                } else {
                   value = 150; // Á©∫Êõ†Ëôï
                }
            }

            // ÂñÆ‰ΩçËΩâÊèõ (È†êË®≠ cm)
            if (unit === 'mm') value *= 10;
            else if (unit === 'm') value /= 100;
            else if (unit === 'in') value /= 2.54;

            return parseFloat(value.toFixed(2));
        }

        // --- Ê∏≤ÊüìÂæ™Áí∞ ---
        function logToConsole(msg) {
            const contentDiv = document.getElementById('console-content');
            if (!contentDiv) return;

            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            // Âä†ÂÖ•ÊôÇÈñìÊà≥Ë®ò (‰æãÂ¶Ç 10:30:05)
            const time = new Date().toLocaleTimeString([], { hour12: false, hour: "2-digit", minute: "2-digit", second:"2-digit" });
            
            // ËôïÁêÜÂÖßÂÆπ (Â¶ÇÊûúÊòØÁâ©‰ª∂Â∞±ËΩâÂ≠ó‰∏≤ÔºåÈÅøÂÖçÈ°ØÁ§∫ [object Object])
            let displayMsg = msg;
            if (typeof msg === 'object') {
                displayMsg = JSON.stringify(msg);
            }

            entry.innerHTML = `<span class="log-time">[${time}]</span> ${displayMsg}`;
            contentDiv.appendChild(entry);
            
            // Ëá™ÂãïÊç≤ÂãïÂà∞Â∫ïÈÉ®
            contentDiv.scrollTop = contentDiv.scrollHeight;
        }

        function clearConsole() {
            const contentDiv = document.getElementById('console-content');
            if (contentDiv) contentDiv.innerHTML = '';
        }

        function onWindowResize() { camera.aspect = container.clientWidth/container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); }
        function onMouseMove(e) { if(!isMouseDown)return; camTheta-=(e.clientX-mouseX)*0.5; camPhi-=(e.clientY-mouseY)*0.5; camPhi=Math.max(10,Math.min(85,camPhi)); mouseX=e.clientX; mouseY=e.clientY; updateCameraPosition(); }
        function onMouseWheel(e) { camRadius+=e.deltaY*0.5; camRadius=Math.max(100,Math.min(1000,camRadius)); updateCameraPosition(); e.preventDefault(); }

        function updateCameraPosition() {
            const radTheta = THREE.MathUtils.degToRad(camTheta), radPhi = THREE.MathUtils.degToRad(camPhi);
            const x = camRadius * Math.sin(radPhi) * Math.sin(radTheta);
            const y = camRadius * Math.cos(radPhi);
            const z = camRadius * Math.sin(radPhi) * Math.cos(radTheta);
            const targetX = state.x * 0.5, targetY = state.y * 0.5, targetZ = state.z;
            camera.position.set(x + targetX, y + 100, z + targetZ + 100);
            camera.lookAt(targetX, targetY, targetZ - 100);
        }

        function animateLoop() {
            requestAnimationFrame(animateLoop);
            
            // 1. Ëû∫ÊóãÊß≥ÊóãËΩâ
            if (state.isFlying) propellers.forEach((p, i) => p.rotation.y += (i%2===0 ? 0.8 : -0.8));
            
            // 2. Êõ¥Êñ∞ÁÑ°‰∫∫Ê©ü‰ΩçÁΩÆ
            if (droneGroup) {
                droneGroup.position.set(state.x, state.y, state.z);
                droneGroup.rotation.y = THREE.MathUtils.degToRad(state.heading);
            }
            
            // 3. Ê™¢Êü•‰ªªÂãôÈÇèËºØ
            if (state.isFlying) checkCityLogic();
            
            // 4. Êõ¥Êñ∞ HUD (Ê†πÊìöÂ†¥ÊôØÈ°ØÁ§∫‰∏çÂêåË≥áË®ä)
            let hudTitle = "", hudContent = "";
            let scoreDisplay = `SCORE: <span style="color:yellow; font-size:1.1rem">${currentScore}</span> / 100<br><hr style="border-color:#444">`;

            if (currentSceneType === 'tunnel') {
                hudTitle = "COMPETITION: TUNNEL";
                // Êää scoreDisplay Âä†Âú®ÊúÄÂâçÈù¢
                hudContent = `${scoreDisplay}Status: ${state.isFlying ? 'FLYING' : 'LANDED'}<br>Alt: ${Math.round(state.y)} cm<br>Dist: ${Math.round(-state.z)} cm`;
            } else if (currentSceneType === 'city') {
                hudTitle = "COMPETITION: CITY";
                hudContent = `${scoreDisplay}Status: ${state.isFlying ? 'FLYING' : 'LANDED'}<br>Alt: ${Math.round(state.y)} cm`;
                if (cityOrder === null) {
                    hudContent += `<span style="color:yellow">‚ö† SEARCHING SIGNAL...</span><br>Fly to Yellow Tower!`;
                } else {
                    let zoneName = cityOrder === 1 ? "ZONE X (Cyan)" : (cityOrder === 2 ? "ZONE Y (Magenta)" : "ZONE Z (Orange)");
                    let zoneColor = cityOrder === 1 ? "#00ffff" : (cityOrder === 2 ? "#ff00ff" : "#ffaa00");
                    hudContent += `ORDER RECEIVED: <b>${cityOrder}</b><br>Target: <span style="color:${zoneColor};font-weight:bold">${zoneName}</span>`;
                }
            } else {
                // Ëá™Áî±È£õË°åÊ®°Âºè HUD
                hudTitle = "FREE FLIGHT";
                hudContent = `${scoreDisplay}Pos: ${Math.round(state.x)}, ${Math.round(state.z)}`;
            }
            
            document.getElementById('hud-display').innerHTML = `<div style="margin-bottom:5px; font-weight:bold; color:#00adb5">${hudTitle}</div>${hudContent}`;
            
            updateCameraPosition();
            renderer.render(scene, camera);
        }

        // ==========================================
        // 3. Âü∑Ë°åÈÇèËºØ (Blockly Integration)
        // ==========================================
        
        function runBlocklyCode() {
            if (state.isRunning) return;
            resetDroneState();
            
            // ÈáçË¶ÅÔºöÈÄôË£°Ë¶ÅÊ∏ÖÁ©∫‰∏¶ÈáçÊñ∞ÁîüÊàê‰ª£Á¢º
            cmdQueue = [];
            try {
                // ‰ΩøÁî® eval Âü∑Ë°å Blockly ÁîüÊàêÁöÑ JS ‰ª£Á¢º
                let code = Blockly.JavaScript.workspaceToCode(workspace);
                eval(code); 
            } catch (e) { alert("Code Error: " + e); return; }
            
            if (cmdQueue.length === 0) { alert("Ë´ãÊãñÊõ≥Á©çÊú®!"); return; }
            
            // È°ØÁ§∫ÈÅãË°åÁãÄÊÖã (ÂèØÈÅ∏)
            // document.getElementById('running-msg').style.display = 'flex';
            executeQueue();
        }

        // ‰øÆÂæ© Reset ÂäüËÉΩÔºöÁ¢∫‰øù 3D Ê®°Âûã‰πüÂõûÂà∞ÂéüÈªû
        // --- Âº∑Âà∂ÈáçÁΩÆÂäüËÉΩ (‰øÆÂæ©Áâà) ---
        
        function resetSimulator() {
            // 1. Âº∑Âà∂ÂÅúÊ≠¢Âü∑Ë°åÊóóÊ®ô
            state.stopSignal = true; 
            state.isRunning = false;
            state.isFlying = false;
            
            // ÈáçÁΩÆÊôÇÊ∏ÖÁ©∫Èù¢Êùø
            clearConsole();

            // 2. Ê∏ÖÁ©∫Êåá‰ª§ÈöäÂàó
            cmdQueue = [];
            waitingForKey = false;

            // 3. „ÄêÈóúÈçµ„ÄëÂº∑Âà∂Â∞áÊâÄÊúâÂ∫ßÊ®ôËÆäÊï∏Ê≠∏Èõ∂
            state.x = 0; 
            state.y = 0; 
            state.z = 0; 
            state.heading = 0; 
            flightState = { roll: 0, pitch: 0, yaw: 0, throttle: 0 }; // ÈáçÁΩÆÈ£õË°åÂßøÊÖã

            // 4. „ÄêÈóúÈçµ„ÄëÁõ¥Êé•Â∞á 3D Ê®°ÂûãÁßªÂãïÂà∞ÂéüÈªû
            if (droneGroup) {
                droneGroup.position.set(0, 0, 0);
                droneGroup.rotation.set(0, 0, 0);
            }

            // 5. ÈáçÁΩÆ‰ªªÂãôÁõ∏ÈóúËÆäÊï∏
            cityOrder = null; 
            hasHoveredTower = false;
            
            // 6. ÈáçÁΩÆÁáàÂÖâËàá UI
            if(droneLedMesh) droneLedMesh.material.color.setHex(0xff0000);
            if(droneLedLight) droneLedLight.color.setHex(0xff0000);
            
            console.log("System Reset to (0,0,0)");
        }

        // ÈÄôË£°‰øùÁïô‰∏ÄÂÄãÁ©∫ÁöÑ resetDroneState ‰ª•Èò≤ÂÖ∂‰ªñÂú∞ÊñπÂëºÂè´Âà∞Â†±ÈåØÔºå
        // ‰ΩÜ‰∏ªË¶ÅÈÇèËºØÈÉΩÂ∑≤Á∂ìÂêà‰ΩµÂà∞ resetSimulator ‰∫Ü„ÄÇ
        function resetDroneState() {
            // Â∑≤Êï¥ÂêàËá≥ resetSimulator
        }
        
        function emergencyStop() { 
            state.stopSignal = true; 
            state.isFlying = false; 
            // Á´ãÂç≥ÂÅúÊ≠¢‰∏¶ÈôçËá≥Âú∞Èù¢È´òÂ∫¶
            state.y = Math.max(0, getGroundHeight(state.x, state.z));
        }
        
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        // Wait Key Promise
        const waitKey = () => new Promise(resolve => {
            waitingForKey = true;
            const check = setInterval(() => {
                if (state.stopSignal) { clearInterval(check); resolve(); }
                if (!waitingForKey) { clearInterval(check); resolve(); }
            }, 100);
        });

        // ÂãïÁï´ËºîÂä©ÂáΩÊï∏
        async function animateAction(durationSec, updateFn) {
            const startTime = performance.now(); const durationMs = durationSec * 1000;
            return new Promise(resolve => {
                function loop(currentTime) {
                    if (state.stopSignal) { resolve(); return; }
                    const elapsed = currentTime - startTime; const progress = Math.min(elapsed / durationMs, 1);
                    updateFn(progress);
                    if (progress < 1) requestAnimationFrame(loop); else resolve();
                } requestAnimationFrame(loop);
            });
        }

        // Âü∑Ë°åÊåá‰ª§ÈöäÂàó
        async function executeQueue() {
            state.isRunning = true; state.stopSignal = false;
            
            for (let i = 0; i < cmdQueue.length; i++) {
                if (state.stopSignal) break;
                const cmd = cmdQueue[i];
                const param = parseFloat(cmd.param);
                
                // Ê™¢Êü•ÊòØÂê¶Â∑≤Ëµ∑È£õ (Èô§‰∫Ü takeoff, set_color, wait_key)
                if (!state.isFlying && cmd.type !== 'takeoff' && cmd.type !== 'set_color' && cmd.type !== 'wait_key') { 
                    await wait(200); continue; 
                }

                switch (cmd.type) {
                    case 'wait_key': await waitKey(); break;
                    case 'takeoff': 
                        await animateAction(1.5, p => state.y = Math.max(state.y, p * 100)); 
                        state.isFlying = true; 
                        hasTakenOff = true; // „ÄêÊñ∞Â¢û„ÄëÊ®ôË®òÂ∑≤Ëµ∑È£õ
                        break;

                    case 'land': 
                        const sy = state.y; const gy = getGroundHeight(state.x, state.z);
                        await animateAction(1.5, p => state.y = sy - ((sy-gy)*p)); 
                        state.isFlying = false; 
                        
                        // „ÄêÊñ∞Â¢û„ÄëÈôçËêΩË®àÂàÜÈÇèËºØ
                        if (hasTakenOff) {
                            // 1. Ë®àÁÆóËàáÁõÆÊ®ôÈªûÁöÑË∑ùÈõ¢ (ÊØïÊ∞èÂÆöÁêÜ)
                            const dist = Math.sqrt(
                                Math.pow(state.x - targetPosition.x, 2) + 
                                Math.pow(state.z - targetPosition.z, 2)
                            );
                            
                            logToConsole(`Landing Distance to target: ${dist.toFixed(1)} cm`);

                            // 2. Âà§Êñ∑ÊòØÂê¶ÂæóÂàÜ (Ë™§Â∑Æ < 20cm)
                            if (dist < 20) {
                                currentScore += 10;
                                logToConsole(`‚úÖ Perfect Landing! (+10 Score)`);
                                // Êí≠Êîæ‰∏ÄÂÄãÁ∞°ÂñÆÁöÑÁâπÊïàÊàñÈü≥ÊïàÊèêÁ§∫ (ÈÄôË£°ÂÖàÁî® Console)
                            } else {
                                logToConsole(`‚ùå Missed Target. (Error > 20cm)`);
                            }
                        }
                        break;

                    case 'hover': await wait(param * 1000); break;
                    case 'set_color': 
                        if(droneLedMesh) droneLedMesh.material.color.set(cmd.param); 
                        if(droneLedLight) droneLedLight.color.set(cmd.param); await wait(200); break;
                    
                    // --- Êñ∞Â¢ûÁöÑ LED ÈÇèËºØ ---
                    case 'led_hex_bright':
                        // ‰ΩøÁî® HEX È°èËâ≤‰∏¶Ë™øÊï¥‰∫ÆÂ∫¶
                        if(droneLedMesh) {
                            let c = new THREE.Color(cmd.color);
                            droneLedMesh.material.color.set(c);
                            // Ê®°Êì¨‰∫ÆÂ∫¶ (0-255 Â∞çÊáâ 0.2-2.0 ÁöÑÂÖâÂº∑)
                            let intensity = (cmd.brightness / 255) * 2.0; 
                            if(droneLedLight) {
                                droneLedLight.color.set(c);
                                droneLedLight.intensity = intensity;
                            }
                        }
                        await wait(100); 
                        break;

                    case 'led_rgb':
                        // ‰ΩøÁî® RGB È°èËâ≤
                        if(droneLedMesh) {
                            // Three.js color takes 0-1, inputs are 0-255
                            let c = new THREE.Color(`rgb(${Math.round(cmd.r)}, ${Math.round(cmd.g)}, ${Math.round(cmd.b)})`);
                            droneLedMesh.material.color.set(c);
                            let intensity = (cmd.brightness / 255) * 2.0;
                            if(droneLedLight) {
                                droneLedLight.color.set(c);
                                droneLedLight.intensity = intensity;
                            }
                        }
                        await wait(100);
                        break;

                    case 'led_off':
                        if(droneLedMesh) droneLedMesh.material.color.setHex(0x000000);
                        if(droneLedLight) droneLedLight.intensity = 0;
                        await wait(100);
                        break;

                    case 'led_seq':
                        // Ê®°Êì¨Â∫èÂàóÊïàÊûú (Á∞°ÂåñÁâàÔºöËÆäËâ≤‰∏¶Á≠âÂæÖÔºåÊ®°Êì¨Âü∑Ë°åÊôÇÈñì)
                        if(droneLedMesh) {
                            let c = new THREE.Color(`rgb(${Math.round(cmd.r)}, ${Math.round(cmd.g)}, ${Math.round(cmd.b)})`);
                            droneLedMesh.material.color.set(c);
                            if(droneLedLight) {
                                droneLedLight.color.set(c);
                                droneLedLight.intensity = 2.0; // ÈñãÁáà
                            }
                        }
                        // Ê®°Êì¨ dimming ÊïàÊûúÔºöÂú® 1.5 ÁßíÂÖßËÆäÊöóÂÜçËÆä‰∫Æ (Á∞°ÊòìÂãïÁï´)
                        if (cmd.seq === 'DIMMING') {
                            await animateAction(1.5, p => {
                                let i = 2.0 * Math.abs(Math.sin(p * Math.PI)); // Á∞°ÂñÆÁöÑÂëºÂê∏ÁáàÊïàÊûú
                                if(droneLedLight) droneLedLight.intensity = i;
                            });
                        } else {
                            await wait(1000); // ÂÖ∂‰ªñÂ∫èÂàóÊö´ÂÅú 1 Áßí
                        }
                        break;    

                    case 'set_var':
                        if(cmd.var === 'ROLL') flightState.roll = cmd.val;
                        if(cmd.var === 'PITCH') flightState.pitch = cmd.val;
                        if(cmd.var === 'YAW') flightState.yaw = cmd.val;
                        if(cmd.var === 'THROTTLE') flightState.throttle = cmd.val;
                        break;

                    case 'set_heading':
                        const startH = state.heading;
                        await animateAction(1.0, p => state.heading = startH + (cmd.val - startH) * p);
                        break;

                    case 'move_complex':
                        // Ê†πÊìö Roll/Pitch Ë®àÁÆó‰ΩçÁßª
                        const rad = THREE.MathUtils.degToRad(state.heading);
                        const speed = 50; 
                        const r = flightState.roll / 100;
                        const p_val = flightState.pitch / 100;
                        const t = flightState.throttle / 100;
                        
                        const dx = (r * Math.cos(rad) - (-p_val) * Math.sin(rad)) * speed;
                        const dz = (r * Math.sin(rad) + (-p_val) * Math.cos(rad)) * speed;
                        const dy = t * speed;

                        const curX = state.x; const curY = state.y; const curZ = state.z;
                        await animateAction(param, prog => {
                            state.x = curX + dx * param * prog;
                            const groundY = getGroundHeight(state.x, state.z);
                            state.y = Math.max(groundY, curY + dy * param * prog);
                            state.z = curZ + dz * param * prog;
                        });
                        break;
                        
                    case 'goto_xyz':
                         const gx = state.x, gY = state.y, gz = state.z;
                         await animateAction(2.0, p => {
                             state.x = gx + (cmd.x - gx)*p;
                             state.y = gY + (cmd.y - gY)*p;
                             state.z = gz + (cmd.z - gz)*p;
                         });
                         break;
                    
                    case 'turn_time':
                        const turnSpd = (cmd.power/100) * 90; 
                        const sHT = state.heading;
                        const dirMult = (cmd.dir === 'LEFT') ? 1 : -1;
                        await animateAction(param, p => { state.heading = sHT + (turnSpd * param * dirMult * p); });
                        break;

                    case 'print':
                        // „Äê‰øÆÊ≠£ÈóúÈçµ„Äë
                        // 1. ÂëºÂè´ÂâõÂâõÂ≠òËµ∑‰æÜÁöÑÂáΩÂºèÔºåÂèñÂæó„ÄåÁèæÂú®„ÄçÁöÑÊï∏ÂÄº
                        let currentMsg = "Undefined";
                        try {
                             currentMsg = cmd.fn(); 
                        } catch(e) {
                             currentMsg = "Error: " + e.message;
                        }

                        // 2. È°ØÁ§∫Âú® Console Èù¢Êùø
                        logToConsole(currentMsg);
                        
                        // 3. ÂêåÊôÇÈ°ØÁ§∫Âú®ÁÄèË¶ΩÂô® Console (Èô§ÈåØÁî®)
                        console.log("%c[Drone Output] " + currentMsg, "color: #00adb5");
                        
                        await wait(200); 
                        break;

                    default:
                        if (cmd.type.startsWith('move_')) {
                            const rad = THREE.MathUtils.degToRad(state.heading); let dx = 0, dz = 0; let dy = 0;
                            if (cmd.type === 'move_forward') { dx = -Math.sin(rad); dz = -Math.cos(rad); }
                            else if (cmd.type === 'move_backward') { dx = Math.sin(rad); dz = Math.cos(rad); }
                            else if (cmd.type === 'move_left') { dx = -Math.cos(rad); dz = Math.sin(rad); }
                            else if (cmd.type === 'move_right') { dx = Math.cos(rad); dz = -Math.sin(rad); }
                            else if (cmd.type === 'move_up') { dy = 1; }
                            else if (cmd.type === 'move_down') { dy = -1; }
                            
                            const sX = state.x; const sZ = state.z; const sY = state.y; const dist = 50 * param;
                            await animateAction(param, (p) => { 
                                state.x = sX + (dx * dist * p); 
                                state.z = sZ + (dz * dist * p);
                                const gH = getGroundHeight(state.x, state.z);
                                state.y = Math.max(gH, sY + (dy * dist * p));
                            });
                        } else if (cmd.type.startsWith('turn_')) {
                            const sH = state.heading; 
                            const deg = cmd.param * (cmd.type==='turn_left'?1:-1);
                            await animateAction(1.0, p => state.heading = sH + deg*p);
                        }
                        break;
                }
                await wait(200);
            }
            
            state.isRunning = false;
        }

        init3D();
    </script>
</body>
</html>